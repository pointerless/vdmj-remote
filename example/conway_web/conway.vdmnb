{"cells":[{"kind":1,"language":"markdown","value":"# Sample VDM Notebook\n\nThis sample VDM Notebook is based on the Conway's game of life VDM model, available [here](https://github.com/leouk/VDM_Toolkit).\n\nThis notebook can intersperse VDM(SL|RT|++) code with Markdown/$\\LaTeX$ to enable explanation of models and mathematical proofs/expressions.\n"},{"kind":2,"language":"vdmsl","value":"/**\n * Conway's Game of Life\n *\n * The universe of the Game of Life is an infinite two-dimensional orthogonal grid of square cells,\n * each of which is in one of two possible states, alive or dead. Every cell interacts with its eight\n * neighbours, which are the cells that are horizontally, vertically, or diagonally adjacent.\n * At each step in time, the following transitions occur:\n *\n *   Any live cell with fewer than two live neighbours dies, as if caused by under-population.\n *   Any live cell with two or three live neighbours lives on to the next generation.\n *   Any live cell with more than three live neighbours dies, as if by overcrowding.\n *   Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.\n *\n * The initial pattern constitutes the seed of the system. The first generation is created by applying\n * the above rules simultaneously to every cell in the seed-births and deaths occur simultaneously,\n * and the discrete moment at which this happens is sometimes called a tick (in other words, each\n * generation is a pure function of the preceding one). The rules continue to be applied repeatedly\n * to create further generations.\n *\n * See http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life.\n * Modelled in VDM-SL by Nick Battle and Peter Gorm Larsen\n */\n\n\n--@WebGUI(\"GUI\", \"/home/harry/WebstormProjects/ConwayWeb/build\")\nmodule Conway\n\nexports all\n\ndefinitions\n\nvalues\n\tGENERATE\t= {3};\t\t-- Number of neighbours to cause generation\n\tSURVIVE\t\t= {2, 3};\t-- Numbers of neighbours to ensure survival, else death\n\t\ntypes\n\tPoint ::\t\t\t\t-- Plain is indexed by integers\n\t\tx : int\n\t\ty : int;\n\t\t\n\tPopulation = set of Point;\n\t\n\tConfiguration ::\n\t\tgridSide : int\n\t\tsleepTime : int\n\t\tpop : Population;\n\t\nfunctions\n\t-- Generate the Points around a given Point\n\taround: Point -> set of Point\n\taround(p) ==\n\t\t{ mk_Point(p.x + x, p.y + y) | x, y in set { -1, 0, +1 }\n\t\t\t& x <> 0 or y <> 0 }\n\tpost card RESULT < 9;\n\t\n\t-- Count the number of live cells around a given point \n\tneighbourCount: Population * Point -> nat\n\tneighbourCount(pop, p) ==\n\t\tcard { q | q in set around(p) & q in set pop }\n\tpost RESULT < 9;\n\n\t-- Generate the set of empty cells that will become live\n\tnewCells: Population -> set of Point\n\tnewCells(pop) ==\n\t\tdunion\n\t\t{\n\t\t\t{ q | q in set around(p)\n\t\t\t\t  & q not in set pop and neighbourCount(pop, q) in set GENERATE }\t\t\n\t\t\t| p in set pop\n\t\t}\n\tpost RESULT inter pop = {};\t\t-- None currently live\n\t\t\n\t-- Generate the set of cells to die\n\tdeadCells: Population -> set of Point\n\tdeadCells(pop) ==\n\t\t{ p | p in set pop\n\t\t\t& neighbourCount(pop, p) not in set SURVIVE }\n\tpost RESULT inter pop = RESULT;\t-- All currently live\n\t\n\t-- Perform one generation\n\t-- @GuiMeta(\"step\", \"pop: generation(pop)\")\n\t-- @GuiMeta(\"init\", \"pop: generation(GOSPER_GLIDER_GUN.pop)\")\n\tgeneration: Population -> Population\n\tgeneration(pop) ==\n\t\t(pop \\ deadCells(pop)) union newCells(pop);\n\n\t-- Generate a sequence of N generations \n\tgenerations: nat1 * Population -> seq of Population\n\tgenerations(n,pop) ==\n\t\tlet new_p = generation(pop)\n\t\tin\n\t\t\tif n = 1\n\t\t\tthen [new_p] \n\t\t\telse [new_p] ^ generations(n-1,new_p)\n\tmeasure n;\n\n    -- Generate an offset of a Population (for testing gliders)\n\toffset: Population * int * int -> Population\n\toffset(pop, dx, dy) ==\n\t\t{ mk_Point(x + dx, y + dy) | mk_Point(x, y) in set pop };\n\t\t\n\t-- Test whether two Populations are within an offset of each other\n\tisOffset: Population * Population * nat1 -> bool\n\tisOffset(pop1, pop2, max) ==\n\t\texists dx, dy in set {-max, ..., max}\n\t\t\t& (dx <> 0 or dy <> 0) and offset(pop1, dx, dy) = pop2;\n\t\t\t\n\t-- Test whether a game is N-periodic\n\tperiodN: Population * nat1 -> bool\n\tperiodN(pop, n) == (generation ** n)(pop) = pop;\n\n\t-- Test whether a game disappears after N generations\n\tdisappearN: Population * nat1 -> bool\n\tdisappearN(pop, n) ==\n\t\t(generation ** n)(pop) = {};\n \n\t-- Test whether a game is N-gliding within max cells\n\tgliderN: Population * nat1 * nat1 -> bool\n\tgliderN(pop, n, max) ==\n\t\tisOffset(pop, (generation ** n)(pop), max);\n\n \t-- Versions of the three tests that check that N is the least value\n\tperiodNP: Population * nat1 -> bool\n\tperiodNP(pop, n) ==\n\t\t{ a | a in set {1, ..., n} & periodN(pop, a) } = {n};\n\n\tdisappearNP: Population * nat1 -> bool\n\tdisappearNP(pop, n) ==\n\t\t{ a | a in set {1, ..., n} & disappearN(pop, a) } = {n};\n\n\tgliderNP: Population * nat1 * nat1 -> bool\n\tgliderNP(pop, n, max) ==\n\t\t{ a | a in set {1, ..., n} & gliderN(pop, a, max) } = {n};\n \n\n-- Test games from http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\nvalues\n\tBLOCK = mk_Configuration(6, 500, { mk_Point(0,0), mk_Point(-1,0), mk_Point(0,-1), mk_Point(-1,-1) });\n\n\tBLINKER = mk_Configuration(6, 500,{ mk_Point(-1,0), mk_Point(0,0), mk_Point(1,0) });\n\t\n\tTOAD = mk_Configuration(6, 500, BLINKER.pop union { mk_Point(0,-1), mk_Point(-1,-1), mk_Point(-2,-1) });\n\t\n\tBEACON = mk_Configuration(8, 500, { mk_Point(-2,0), mk_Point(-2,1), mk_Point(-1,1), mk_Point(0,-2), \n            mk_Point(1,-2), mk_Point(1,-1 )});\n            \n\tPULSAR =  mk_Configuration(18, 1000, let quadrant = { mk_Point(2,1), mk_Point(3,1), mk_Point(3,2),\n                           mk_Point(1,2), mk_Point(1,3), mk_Point(2,3),\n                           mk_Point(5,2), mk_Point(5,3), mk_Point(6,3), mk_Point(7,3),\n                           mk_Point(2,5), mk_Point(3,5), mk_Point(3,6), mk_Point(3,7) }\n\t\t\tin\n\t\t\t\tquadrant union\n\t\t\t\t{ mk_Point(-x, y)| mk_Point(x, y) in set quadrant } union\n\t\t\t\t{ mk_Point(x, -y)| mk_Point(x, y) in set quadrant } union\n\t\t\t\t{ mk_Point(-x, -y)| mk_Point(x, y) in set quadrant });\n\t\t\t\t\n    DIEHARD = mk_Configuration(34, 300, {mk_Point(0,1),mk_Point(1,1),mk_Point(1,0),\n             mk_Point(0,5),mk_Point(0,6),mk_Point(0,7),mk_Point(2,6)});\n      \n    GLIDER = mk_Configuration(40, 100, { mk_Point(1,0), mk_Point(2,0), mk_Point(3,0), mk_Point(3,1), mk_Point(2,2) });      \n       \n    GOSPER_GLIDER_GUN =\n    \tmk_Configuration(40, 50, {\n        mk_Point(2,0), mk_Point(2,1), mk_Point(2,2), mk_Point(3,0), mk_Point(3,1),\n        mk_Point(3,2), mk_Point(4,-1), mk_Point(4,3), mk_Point(6,-2), mk_Point(6,-1),\n        mk_Point(6,3), mk_Point(6,4), mk_Point(16,1), mk_Point(16,2), mk_Point(17,1),\n        mk_Point(17,2), mk_Point(-1,-1), mk_Point(-2,-2), mk_Point(-2,-1), mk_Point(-2,0),\n        mk_Point(-3,-3), mk_Point(-3,1), mk_Point(-4,-1), mk_Point(-5,-4), mk_Point(-5,2),\n        mk_Point(-6,-4), mk_Point(-6,2), mk_Point(-7,-3), mk_Point(-7,1), mk_Point(-8,-2),\n        mk_Point(-8,-1), mk_Point(-8,0), mk_Point(-17,-1), mk_Point(-17,0), mk_Point(-18,-1),\n        mk_Point(-18,0)});\n        \n   functions\n\ttests: () -> seq of bool\n\ttests() ==\n\t[\n\t\tperiodNP(BLOCK.pop,\t\t1),\t-- ie. constant\n\t\tperiodNP(BLINKER.pop,\t2),\n\t\tperiodNP(TOAD.pop,\t\t2),\n\t\tperiodNP(BEACON.pop,\t2),\n\t\tperiodNP(PULSAR.pop,\t3),\n\t\tgliderNP(GLIDER.pop,\t4, 1)\n\t\t-- disappearNP(DIEHARD.pop, 130)\t-- This takes a few minutes!\n\t]\n\tpost elems RESULT = {true};\n\t          \n             \nend Conway\n"},{"kind":2,"language":"vdmrt","value":"system Example\n\ninstance variables\n    A : nat1 := 1;\n\nend Example"}]}